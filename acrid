#!/usr/bin/python3
#+
# Simple tool to set/show metadata in a PDF file, using the
# pikepdf toolkit.
#
# Invocation details are documented in the acrid(1) man page,
# included with this script.
#
# Copyright 2021 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

import sys
import os
import time
import calendar
import datetime
try :
    import zoneinfo
except ImportError :
    zoneinfo = None
#end try
import fnmatch
import re
import getopt
from pikepdf import \
    Pdf

#+
# Useful stuff
#-

valid_info_keys = \
    [ # cf page 550 of PDF 32000-1:2008
        "Author",
        "CreationDate",
        "Creator",
        "Keywords",
        "ModDate",
        "Producer",
        "Subject",
        "Title",
        "Trapped",
    ]

#+
# Definitions of valid commands.
#
# Each command function is passed two arguments: the first is
# the list of positional arguments, and the second is the
# dictionary of option keywords and corresponding values
# that were specified.
#-

def cmd_help(args, opts) :
    "shows the user the help description for a command, or for the help" \
    " command itself if no valid command is given."
    command_candidates = None
    command_match = None
    if len(args) == 1 :
        cmd = args[0]
        if cmd not in recognized_commands :
            command_match = cmd
            cmd = None
            command_candidates = list \
              (
                c for c in recognized_commands.keys()
                if fnmatch.fnmatch(c, command_match)
              )
        #end if
    else :
        cmd = "help"
        command_candidates = recognized_commands.keys()
    #end if
    if cmd != None :
        sys.stderr.write \
          (
                "Usage:\n\n\t%s %s %s\n\n%s.\n"
            %
                (
                    sys.argv[0],
                    cmd,
                    recognized_commands[cmd]["help_usage"],
                    recognized_commands[cmd]["help_descr"],
                )
          )
    #end if
    if command_candidates != None :
        if len(command_candidates) != 0 :
            sys.stderr.write \
              (
                    "\nValid commands%(matching)s are: %(commands)s.\n"
                %
                    {
                        "matching" :
                            ["", " matching \"%s\"" % command_match][command_match != None],
                        "commands" : ", ".join(sorted(command_candidates)),
                    }
              )
        else :
            sys.stderr.write("No commands matching \"%s\".\n" % command_match)
        #end if
    #end if
#end cmd_help

def cmd_setinfo(args, opts) :
    to_set = opts.get("set", [])
    to_del = opts.get("del", [])
    delxmp = "delxmp" in opts
    delall = "delall" in opts
    if len(to_set) + len(to_del) == 0 and not delall and not delxmp :
        raise getopt.GetoptError("nothing to do")
    #end if
    if delall and len(to_del) != 0 :
        raise getopt.GetoptError("--delall leaves nothing for --del to do")
    #end if
    to_set = list(s.split("=", 1) for s in to_set)
    to_change = {}
    duplicated = set()
    for keyword, value in to_set :
        if keyword in to_change :
            duplicated.add(keyword)
        #end if
        to_change[keyword] = value
    #end for
    if len(duplicated) != 0 :
        raise getopt.GetoptError("duplicated keywords for --set: %s" % ", ".join(sorted(duplicated)))
    #end if
    duplicated = set(to_change.keys()) & set(to_del)
    if len(duplicated) != 0 :
        raise getopt.GetoptError \
          (
            "duplicated keywords for both --set and --del: %s" % ", ".join(sorted(duplicated))
          )
    #end if
    for keyword in to_del :
        to_change[keyword] = None
    #end for
    if "allow-nonstd" not in opts :
        invalid = set(k for k in to_change if k not in set(valid_info_keys))
        if len(invalid) != 0 :
            raise getopt.GetoptError("invalid keywords: %s" % ", ".join(sorted(invalid)))
        #end if
    #end if
    pdf = Pdf.open(args[0])
    docinfo = pdf.docinfo
    if delall :
        for keyword in list(docinfo.keys()) :
            del docinfo[keyword]
        #end for
    #end if
    for keyword, value in to_change.items() :
        keyword = "/" + keyword
        if value != None :
            docinfo[keyword] = value
        else :
            if keyword in docinfo :
                del docinfo[keyword]
            #end if
        #end if
    #end for
    if delxmp and hasattr(pdf, "root") and hasattr(pdf.root, "Metadata") :
        del pdf.root.Metadata
    #end if
    pdf.save(args[1])
#end cmd_setinfo

def cmd_showinfo(args, opts) :
    pdf = Pdf.open(args[0])
    sys.stdout.write(repr(pdf.docinfo))
    sys.stdout.write("\n")
    if hasattr(pdf, "root") and hasattr(pdf.root, "Metadata") :
        sys.stdout.write(pdf.root.Metadata.read_bytes().decode())
        sys.stdout.write("\n")
    #end if
#end cmd_showinfo

def cmd_getinfo(args, opts) :
    pdf = Pdf.open(args[0])
    keyword = args[1]
    info = pdf.docinfo
    if keyword in info or "default" not in opts :
        sys.stdout.write(str(info[keyword]))
    else :
        sys.stdout.write(opts["default"])
    #end if
    sys.stdout.write("\n")
#end cmd_getinfo

def cmd_format_date(args, opts) :
    timestamp = int(args[0])
    use_utc = "utc" in opts
    use_timezone = opts.get("timezone")
    if use_timezone != None and zoneinfo == None :
        raise getopt.GetoptError("--timezone option not available on this Python version")
    #end if
    if use_timezone != None and use_utc :
        raise getopt.GetoptError("can’t specify both --timezone and --utc")
    #end if
    if use_timezone != None :
        the_time = datetime.datetime.fromtimestamp \
          (
            timestamp,
            tz = zoneinfo.ZoneInfo(use_timezone)
          )
        pieces = the_time.timetuple()
        tzdelta = round(the_time.utcoffset().total_seconds())
    else :
        pieces = (time.localtime, time.gmtime)[use_utc](timestamp)
        tzdelta = (pieces.tm_gmtoff, "Z")[use_utc]
    #end if
    if isinstance(tzdelta, int) :
        assert tzdelta % 60 == 0, "TZ delta is not a whole number of minutes"
        sign = ("+", "-")[tzdelta < 0]
        tzdelta = abs(tzdelta)
        tzdelta = "%s%02d'%02d'" % (sign, tzdelta // 3600, tzdelta // 60 % 60)
    #end if
    format = "D:%Y%m%d%H%M%S"
    sys.stdout.write("%s%s\n" % (time.strftime(format, pieces), tzdelta))
#end cmd_format_date

def cmd_parse_date(args, opts) :
    datetime = args[0]
    pieces = re.fullmatch \
      (
        r"D\:(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})([+\-]\d+\D\d+\D)?",
        datetime
      )
    if pieces == None :
        raise ValueError("invalid PDF date/time %s" % repr(datetime))
    #end if
    pieces = pieces.groups()
    tzdelta = pieces[6]
    if tzdelta != None :
        tzdelta = re.fullmatch(r"(.)(\d+)\D(\d+)\D", tzdelta).groups()
        tzdelta = (int(tzdelta[1]) * 60 + int(tzdelta[2])) * 60 * (1, -1)[tzdelta[0] == "-"]
    else :
        tzdelta = 0
    #end if
    pieces = tuple(int(p) for p in pieces[:6])
    result = calendar.timegm(pieces + (0, 0, -1)) - tzdelta
    sys.stdout.write("%d\n" % result)
#end cmd_parse_date

recognized_commands = \
    {
# key is command name, value is dictionary with following fields:
#     args -- nr required positional args, or tuple of min and max nr required positional args
#     opts -- tuple of long option names. If a name ends in an equal sign, then it takes a value.
#     multivalued -- optional tuple of option keywords which can occur multiple times
#     required -- optional tuple of option keywords which must be present
#     help_usage -- used to construct a usage string when giving help for the command.
#     help_descr -- explanatory text shown when giving help for the command.
#     action -- the function to invoke to actually perform the command.

        "help" :
            {
                "args" : (0, 1),
                "opts" : (),
                "action" : cmd_help,
                "help_usage" : "[cmd]",
                "help_descr" : "gives help about the specified command",
            },

        "setinfo" :
            {
                "args" : 2,
                "opts" : ("allow-nonstd", "delall", "del=", "delxmp", "set="),
                "multivalued" : ("del", "set"),
                "action" : cmd_setinfo,
                "help_usage" :
                    "[--allow-nonstd] [--delxmp] [--delall] [--del=«keyword» ...]"
                    " [--set=«keyword»=«value» ...]"
                    " «in pdf file» «out pdf file»",
                "help_descr" :
                    "changes metadata on the input PDF file and saves the result as the output",
            },

        "showinfo" :
            {
                "args" : 1,
                "opts" : (),
                "action" : cmd_showinfo,
                "help_usage" : "«pdf file»",
                "help_descr" : "shows metadata for the specified PDF file",
            },

        "getinfo" :
            {
                "args" : 2,
                "opts" : ("default=",),
                "action" : cmd_getinfo,
                "help_usage" : "«pdf file» «keyword»",
                "help_descr" :
                    "retrieves the specified metadata value from the Info"
                    " dictionary in the PDF file",
            },

        "format_date" :
            {
                "args" : 1,
                "opts" : ("timezone=", "utc"),
                "action" : cmd_format_date,
                "help_usage" : "«utc-seconds»",
                "help_descr" :
                    "formats UTC seconds into a timestamp of the format D:YYYYmmddHHMMSS[±tzd]",
            },

        "parse_date" :
            {
                "args" : 1,
                "opts" : (),
                "action" : cmd_parse_date,
                "help_usage" : "«date-time-string»",
                "help_descr" :
                    "parses a timestamp of the format D:YYYYmmddHHMMSS[±tzd],"
                    " returning UTC seconds",
            },

    } # recognized_commands

#+
# Mainline
#-

def mainline() :
    if len(sys.argv) < 2 :
        raise getopt.GetoptError("need at least one arg, the cmd to execute")
    #end if
    cmd = sys.argv[1]
    cmd_entry = recognized_commands.get(cmd)
    if cmd_entry == None :
        raise getopt.GetoptError("unrecognized command %s" % repr(cmd))
    #end if
    opts_list, args = getopt.gnu_getopt \
      (
        sys.argv[2:],
        "",
        cmd_entry["opts"]
      )
    if type(cmd_entry["args"]) == tuple :
        if \
          (
                len(args) < cmd_entry["args"][0]
            or
                len(args) > cmd_entry["args"][1]
          ):
            raise getopt.GetoptError \
              (
                "%s command needs %u..%u args" % ((cmd,) + cmd_entry["args"])
              )
        #end if
    else :
        if len(args) != cmd_entry["args"] :
            raise getopt.GetoptError \
              (
                "%s command needs exactly %u args" % (cmd, cmd_entry["args"])
              )
        #end if
    #end if
    opts = {}
    multi_opts = frozenset(cmd_entry.get("multivalued", ()))
    for keyword, value in opts_list :
        if keyword[:2] == "--" :
            keyword = keyword[2:]
            if keyword in multi_opts :
                values = opts.get(keyword, [])
                values.append(value)
                opts[keyword] = values
            else :
                opts[keyword] = value
            #end if
        #end if
    #end for
    required_opts = cmd_entry.get("required")
    if required_opts != None :
        missing = set(required_opts) - set(opts.keys())
        if len(missing) != 0 :
            raise getopt.GetoptError \
              (
                "%s command needs option(s) %s" % (cmd, ",".join(tuple(missing)))
              )
        #end if
    #end if
    cmd_entry["action"](args, opts) # can raise exceptions
#end mainline

mainline()
